@page "/reader/{ContentId:int}"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using System.Collections.Generic
@using System.Text.RegularExpressions
@using TheArchives.Shared
@attribute [Authorize]
@implements IAsyncDisposable
@inject HttpClient Http
@inject IJSRuntime JS

<main class="reader" @ref="readerRef" @onclick="OnReaderClick"> 
    <div class="reader-hidden" @ref="hiddenRef">
        <h1>@content?.Title</h1>
        
        @foreach (var paragraph in paragraphs ?? Enumerable.Empty<string>())
        {
            <p>@paragraph</p>
        }
    </div>

    <Loader Loading="loading" />

    <div
        class="pager fade @(loading ? "hidden" : "shown")"
        style="transform: translateX(-@(pageWidth * page)px);width: @(pageCount * pageWidth)px;columns: @pageCount @(columnWidth)px;height: @(columnHeight)px">
            <h1>@content?.Title</h1>

            @foreach (var paragraph in paragraphs ?? Enumerable.Empty<string>())
            {
                <p>@paragraph</p>
            }
    </div>

    <div class="progress-count"><small><b>Page @(page + 1) of @(pageCount)</b></small></div>

    <div class="progress-percent"><small><b>@(Math.Ceiling(progress))%</b></small></div>

    <div class="progress-bar" style="width: @(progress)%;"></div>
</main>

@code {
    [Parameter]
    public int ContentId { get; set; }

    private ElementReference hiddenRef { get; set; }

    private ElementReference readerRef { get; set; }

    private double progress => page / (double)Math.Max(1, pageCount - 1) * 100D;

    private int page { get; set; } = 0;

    private int pageCount { get; set; } = 1;

    private double hiddenHeight { get; set; } = 0;

    private double pageHeight { get; set; } = 0;

    private double pageWidth { get; set; } = 0;

    private double columnHeight { get; set; } = 0;

    private double columnWidth { get; set; } = 0;

    private string text { get; set; } = string.Empty;

    private IEnumerable<string>? paragraphs { get; set; }

    private Content? content { get; set; }

    private static Action<double, double, double, double>? HiddenRefResizedAction;

    private static Action<double, double, double, double>? ReaderRefResizedAction;

    private static Action<double, double>? ReaderRefTouchStartAction;

    private static Action<double, double>? ReaderRefTouchMoveAction;

    private bool loading { get; set; }

    private bool readerRendered { get; set; }

    private bool hiddenRendered { get; set; }

    private double xDown { get; set; } = double.MinValue;

    private double yDown { get; set; } = double.MinValue;

    public async ValueTask DisposeAsync()
    {
        // If we don't run them all at once, we risk the element references being disposed in the meantime
        await Task.WhenAll(
            JS.InvokeVoidAsync("interopFunctions.unObserveHiddenRefResized", hiddenRef).AsTask(),
            JS.InvokeVoidAsync("interopFunctions.unObserveReaderRefResized", readerRef).AsTask(),
            JS.InvokeVoidAsync("interopFunctions.disposeBody").AsTask(),
            JS.InvokeVoidAsync("interopFunctions.unlistenToSwipes").AsTask()
        ).ConfigureAwait(false);
    }

    [JSInvokable]
    public static void HiddenRefResized(double height, double width, double left, double top)
    {
        HiddenRefResizedAction?.Invoke(height, width, left, top);
    }

    [JSInvokable]
    public static void ReaderRefResized(double height, double width, double left, double top)
    {
        ReaderRefResizedAction?.Invoke(height, width, left, top);
    }

    [JSInvokable]
    public static void ReaderRefTouchStart(double clientX, double clientY)
    {
        ReaderRefTouchStartAction?.Invoke(clientX, clientY);
    }

    [JSInvokable]
    public static void ReaderRefTouchMove(double clientX, double clientY)
    {
        ReaderRefTouchMoveAction?.Invoke(clientX, clientY);
    }

    private void ReaderRefResizedActionCallback(double height, double width, double left, double top)
    {
        var gutterY = 35; // top + bottom padding
        var gutterX = 20; // left + right padding

        pageHeight = height; // height before padding
        pageWidth = width; // width before padding
        columnHeight = height - gutterY; // height after padding
        columnWidth = width - gutterX; // width after padding

        readerRendered = true;
        UpdatePositions();
    }

    private void HiddenRefResizedActionCallback(double height, double width, double left, double top)
    {
        hiddenHeight = height; // hidden ref height after padding
        hiddenRendered = true;
        UpdatePositions();
    }

    private void UpdatePositions() {
        if (hiddenRendered && readerRendered)
        {
            loading = false;
        }
        
        pageCount = (int)Math.Floor(hiddenHeight / Math.Max(1, columnHeight)) + 1;
        StateHasChanged();
    }

    private void ReaderRefTouchStartCallback(double clientX, double clientY)
    {
        xDown = clientX;
        yDown = clientY;
    }

    private void ReaderRefTouchMoveCallback(double clientX, double clientY)
    {
        if (xDown == double.MinValue || yDown == double.MinValue)
        {
            return;
        }

        var xUp = clientX;
        var yUp = clientY;

        var xDiff = xDown - xUp;
        var yDiff = yDown - yUp;

        if (Math.Abs(xDiff) > Math.Abs(yDiff))
        {
            if (xDiff > 0)
            {
                GoNext();
                StateHasChanged();
            }
            else
            {
                GoPrev();
                StateHasChanged();
            }
        }
        else
        {
            if (yDiff > 0)
            {
                // Swipe up
            }
            else
            {
                // Swipe down
            }
        }

        xDown = double.MinValue;
        yDown = double.MinValue;
    }

    protected override async Task OnInitializedAsync()
    {
        loading = true;
        pageCount = 1;
        page = 0;
        paragraphs = Enumerable.Empty<string>();
        readerRendered = false;
        hiddenRendered = false;

        HiddenRefResizedAction = HiddenRefResizedActionCallback;
        ReaderRefResizedAction = ReaderRefResizedActionCallback;
        ReaderRefTouchMoveAction = ReaderRefTouchMoveCallback;
        ReaderRefTouchStartAction = ReaderRefTouchStartCallback;

        await GetContent();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            await JS.InvokeVoidAsync("interopFunctions.initializeBody");
            await JS.InvokeVoidAsync("interopFunctions.listenToSwipes");
            await JS.InvokeVoidAsync("interopFunctions.observeHiddenRefResized", hiddenRef);
            await JS.InvokeVoidAsync("interopFunctions.observeReaderRefResized", readerRef);
        }
    }

    private async Task OnReaderClick(MouseEventArgs e) {
        var result = await JS.InvokeAsync<BoundingClientRect>("interopFunctions.getBoundingClientRect", readerRef);
        var percentX = e.ClientX / result.Width;

        if (percentX > 0.1) {
            GoNext();
        } else if (percentX <= 0.1) {
            GoPrev();
        }
    }

    private void GoNext()
    {
        if (page + 1 < pageCount) 
        {
            page++;
            StateHasChanged();
        }
    }

    private void GoPrev()
    {
        if (page - 1 >= 0)
        {
            page--;
            StateHasChanged();
        }
    } 

    private async Task GetContent()
    {
        try
        {
            // Make requests
            var getTextTaask = Http.GetStringAsync($"/api/content/text/{ContentId}");
            var getContentTask = Http.GetFromJsonAsync<Content>($"/api/content/{ContentId}");
            await Task.WhenAll(getTextTaask, getContentTask);

            text = getTextTaask.Result;
            content = getContentTask.Result;
            
            // Parse response
            var noConsecutive = new Regex(@"(.)\1\1\1\1\1+").Replace(text, string.Empty); // replace consecutive identical characters in text
            paragraphs = new Regex(@"\n\n").Split(noConsecutive).Where((s) => s.Length > 0); // split into paragraphs
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
    }
}