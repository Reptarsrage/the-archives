@page "/reader/{ContentId:int}"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using System.Collections.Generic
@using System.Text.RegularExpressions
@using TheArchives.Shared
@attribute [Authorize]
@implements IAsyncDisposable
@inject HttpClient Http
@inject IJSRuntime JS

<main class="reader" @ref="readerRef" @onclick="OnReaderClick"> 
    <div class="reader-hidden" @ref="hiddenRef">
        <h1>@content?.Title</h1>
        
        @foreach (var paragraph in paragraphs ?? Enumerable.Empty<string>())
        {
            <p>@paragraph</p>
        }
    </div>

    <Loader Loading="loading" />

    <div
      class="pager fade @(loading ? "hidden" : "shown")"
      style="transform: translate(-@(pageWidth * page)px);width: @(pageCount * pageWidth)px;height: @(readerHeight)px;column-count: @pageCount;">
        <h1>@content?.Title</h1>

        @foreach (var paragraph in paragraphs ?? Enumerable.Empty<string>())
        {
            <p>@paragraph</p>
        }
    </div>
</main>

@code {
    [Parameter]
    public int ContentId { get; set; }

    private ElementReference hiddenRef { get; set; }

    private ElementReference readerRef { get; set; }

    private int page { get; set; } = 0;

    private int pageCount { get; set; } = 0;

    private decimal pageHeight { get; set; } = 0;

    private decimal pageWidth { get; set; } = 0;

    private decimal readerHeight { get; set; } = 0;

    private string text { get; set; } = string.Empty;

    private IEnumerable<string>? paragraphs { get; set; }

    private Content? content { get; set; }

    private static Action<decimal, decimal, decimal, decimal>? HiddenRefResizedAction;

    private static Action<decimal, decimal, decimal, decimal>? ReaderRefResizedAction;

    private bool loading { get; set; }

    public async ValueTask DisposeAsync()
    {
        await DisposeAsyncCore();
        GC.SuppressFinalize(this);
    }

    protected virtual async ValueTask DisposeAsyncCore()
    {
        await JS.InvokeVoidAsync("interopFunctions.disposeBody").ConfigureAwait(false);
        await JS.InvokeVoidAsync("interopFunctions.unObserveHiddenRefResized", hiddenRef).ConfigureAwait(false);
        await JS.InvokeVoidAsync("interopFunctions.unObserveReaderRefResized", readerRef).ConfigureAwait(false);
    }

    [JSInvokable]
    public static void HiddenRefResized(decimal height, decimal width, decimal left, decimal top)
    {
        HiddenRefResizedAction?.Invoke(height, width, left, top);
    }

    [JSInvokable]
    public static void ReaderRefResized(decimal height, decimal width, decimal left, decimal top)
    {
        ReaderRefResizedAction?.Invoke(height, width, left, top);
    }

    private void ReaderRefResizedActionCallback(decimal height, decimal width, decimal left, decimal top)
    {
        readerHeight = height == 0 ? 1 : height;
        pageCount = (int)Math.Floor(pageHeight / readerHeight) + 1;
        StateHasChanged();
    }

    private void HiddenRefResizedActionCallback(decimal height, decimal width, decimal left, decimal top)
    {
        var gutterX = left * 2;
        var gutterY = top * 2;
        var totalHeight = height + gutterY;
        var totalWidth = width + gutterX;
        
        pageHeight = totalHeight;
        pageWidth = totalWidth;
        readerHeight = readerHeight == 0 ? 1 : readerHeight;
        pageCount = (int)Math.Floor(pageHeight / readerHeight) + 1;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        loading = true;
        paragraphs = Enumerable.Empty<string>();
        HiddenRefResizedAction = HiddenRefResizedActionCallback;
        ReaderRefResizedAction = ReaderRefResizedActionCallback;
        await GetContent();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            await JS.InvokeVoidAsync("interopFunctions.initializeBody");
            await JS.InvokeVoidAsync("interopFunctions.observeHiddenRefResized", hiddenRef);
            await JS.InvokeVoidAsync("interopFunctions.observeReaderRefResized", readerRef);
        }
    }

    private async Task OnReaderClick(MouseEventArgs e) {
        var result = await JS.InvokeAsync<BoundingClientRect>("interopFunctions.getBoundingClientRect", readerRef);
        var percentX = e.ClientX / result.Width;

        if (percentX > 0.1 && page + 1 < pageCount) {
            page++;
        } else if (percentX <= 0.1 && page - 1 >= 0) {
            page--;
        }
    }

    private async Task GetContent()
    {
        try
        {
            // Make requests
            var getTextTaask = Http.GetStringAsync($"/api/content/text/{ContentId}");
            var getContentTask = Http.GetFromJsonAsync<Content>($"/api/content/{ContentId}");
            await Task.WhenAll(getTextTaask, getContentTask);

            text = getTextTaask.Result;
            content = getContentTask.Result;
            
            // Parse response
            var noConsecutive = new Regex(@"(.)\1\1\1\1\1+").Replace(text, string.Empty); // replace consecutive identical characters in text
            paragraphs = new Regex(@"\n\n").Split(noConsecutive).Where((s) => s.Length > 0); // split into paragraphs
            page = 0;
            loading = false;
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
    }
}